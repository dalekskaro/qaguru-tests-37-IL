## Урок 4: Selenide #1
[4. Selenide #1. Алексей Виноградов](https://school.qa.guru/pl/teach/control/lesson/view?id=343208841&editMode=0)

1. DOM для начинающих (запись)
2. Лайвкодинг – простые тесты для GitHub
3. Лайвкодинг – GitHub с решением некоторых типичных проблем

Про элементы DOM:
- `.classname` - пишем точку, когда надо искать по имени класса
- `#id` - пишем решетку, когда ищем по id
- `[attribute='attribue name']` - пишем [], когда ищем атрибут
- `a` - тег a

можно комбинировать: `a[href='abc'].red`- тег `а`, атрибут `href` со значением `abc` и должен быть класс `red`


### Домашнее задание для урока 4:

#### 1. Есть ли разница между `$("h1 div");` и `$("h1").$("div");`?
Может ли привести к тому что, поиск найдёт разные элементы? Если может - приведите пример, когда.

**Ответ:** На первый взгляд разницы нет. Я написала тест с проверками:
````java
$("body div").should(appear);
$("body").$("div").should(appear);
````
И тест успешно прошел. И казалось бы, можно написать ответ: "Нет, разницы нет." и отправить ответ.

Но все же хочется покпаться дальше и я решила обратиться к предыдущему занятию.

Видео по занятию "_3. Погружаемся в инструментарий и библиотеки_", тайминг 1:39:20, лектор изменяет `$("#output").$("#name")` на `$("#output #name")`, говоря, что разницы между ними нет, и опять можно было бы ответить "Нет, разницы нет." и отправить ответ.
Но в лекции были айди элементов, а не теги. Поэтому я решила копать еще дальше и найти страницу, где есть и div и h1. Такие теги нашлись в https://demoqa.com/frames Поэтому я написала следующий тест:
````java
@Test
void letsSeeDivTest() {
open("https://demoqa.com/frames");
$("div h1").should(appear);
$("div").$("h1").should(appear);
}
````
И уже этот тест упал на второй проверке. Текст ошибки гласил: `Element not found {div/h1}`. Ага, уже значит разница какая-то есть, значит надо посмотреть, какая будет ошибка, если поменять один из тегов в первой проверке на несуществующий. И следующий текст ошибки был: `Element not found {div h12}`. Бинго!
То есть когда мы пишем `$("div h1»)`, то selenide так и смотрит данный элемент и может спокойно найти именно то, как мы элемент обозначали. А запись вида `$("div").$("h1")` selenide преобразует и записывает через `div/h1` (какой-то xpath получается)

Остался один вопрос: почему так происходит?

Тут уже скажу честно, мой мозг понимал, что дело вероятнее всего кроется в родительских элементах, но сама суть до меня не доходила, поэтому я обратилась за помощью к ИИ.

И тут уже я поняла, что на "слона в комнате" я почти не обратила внимание. 
* В первом варианте `$("div h1»)` у нас идет **один селектор**. И эта запись готовит селениду: найди мне внутри тега `div` тег `h1`. 
* Во втором варианте `$("div").$("h1")` у нас **цепочка** поиска. Что означает: найти первый элемент `div`, а потом внутри него найди `h1`. 

То есть если внутри первого элемента по dom-дереву не будет найден второй элемент цепочки, то тест упадет. В то время как первый вариант записи ищет сразу такой существующий элемент (если он конечно существует)

Для кода, указанного ниже, запись типа `$("div h1»)` найдет элемент, а запись типа `$("div").$("h1")` элемент не найдет, потому что в первом `div` нет внутри `h1`.
````html
<div></div>
<div>
    <h1>hello</h1>
</div>
````

#### 2. Разработайте следующий автотест:

- Откройте страницу Selenide в Github
- Перейдите в раздел Wiki проекта
- Убедитесь, что в списке страниц (Pages) есть страница SoftAssertions
- Откройте страницу SoftAssertions, проверьте что внутри есть пример кода для JUnit5
